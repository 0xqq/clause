/***************************************************************************
 *
 * Copyright (c) 2019 Chatopera.Inc, Inc. All Rights Reserved
 *
 **************************************************************************/

/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "server_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace chatopera {
namespace bot {
namespace sysdicts {


Entity::~Entity() throw() {
}


void Entity::__set_slotname(const std::string& val) {
  this->slotname = val;
  __isset.slotname = true;
}

void Entity::__set_dictname(const std::string& val) {
  this->dictname = val;
  __isset.dictname = true;
}

void Entity::__set_val(const std::string& val) {
  this->val = val;
  __isset.val = true;
}

void Entity::__set_score(const double val) {
  this->score = val;
  __isset.score = true;
}
std::ostream& operator<<(std::ostream& out, const Entity& obj) {
  obj.printTo(out);
  return out;
}


uint32_t Entity::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);

    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }

    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->slotname);
          this->__isset.slotname = true;
        } else {
          xfer += iprot->skip(ftype);
        }

        break;

      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dictname);
          this->__isset.dictname = true;
        } else {
          xfer += iprot->skip(ftype);
        }

        break;

      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->val);
          this->__isset.val = true;
        } else {
          xfer += iprot->skip(ftype);
        }

        break;

      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->score);
          this->__isset.score = true;
        } else {
          xfer += iprot->skip(ftype);
        }

        break;

      default:
        xfer += iprot->skip(ftype);
        break;
    }

    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Entity::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Entity");

  if (this->__isset.slotname) {
    xfer += oprot->writeFieldBegin("slotname", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->slotname);
    xfer += oprot->writeFieldEnd();
  }

  if (this->__isset.dictname) {
    xfer += oprot->writeFieldBegin("dictname", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->dictname);
    xfer += oprot->writeFieldEnd();
  }

  if (this->__isset.val) {
    xfer += oprot->writeFieldBegin("val", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->val);
    xfer += oprot->writeFieldEnd();
  }

  if (this->__isset.score) {
    xfer += oprot->writeFieldBegin("score", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->score);
    xfer += oprot->writeFieldEnd();
  }

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Entity &a, Entity &b) {
  using ::std::swap;
  swap(a.slotname, b.slotname);
  swap(a.dictname, b.dictname);
  swap(a.val, b.val);
  swap(a.score, b.score);
  swap(a.__isset, b.__isset);
}

Entity::Entity(const Entity& other0) {
  slotname = other0.slotname;
  dictname = other0.dictname;
  val = other0.val;
  score = other0.score;
  __isset = other0.__isset;
}
Entity& Entity::operator=(const Entity& other1) {
  slotname = other1.slotname;
  dictname = other1.dictname;
  val = other1.val;
  score = other1.score;
  __isset = other1.__isset;
  return *this;
}
void Entity::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Entity(";
  out << "slotname=";
  (__isset.slotname ? (out << to_string(slotname)) : (out << "<null>"));
  out << ", " << "dictname=";
  (__isset.dictname ? (out << to_string(dictname)) : (out << "<null>"));
  out << ", " << "val=";
  (__isset.val ? (out << to_string(val)) : (out << "<null>"));
  out << ", " << "score=";
  (__isset.score ? (out << to_string(score)) : (out << "<null>"));
  out << ")";
}


Data::~Data() throw() {
}


void Data::__set_rc(const int32_t val) {
  this->rc = val;
  __isset.rc = true;
}

void Data::__set_msg(const std::string& val) {
  this->msg = val;
  __isset.msg = true;
}

void Data::__set_error(const std::string& val) {
  this->error = val;
  __isset.error = true;
}

void Data::__set_query(const std::string& val) {
  this->query = val;
  __isset.query = true;
}

void Data::__set_entities(const std::vector<Entity> & val) {
  this->entities = val;
  __isset.entities = true;
}
std::ostream& operator<<(std::ostream& out, const Data& obj) {
  obj.printTo(out);
  return out;
}


uint32_t Data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true) {
    xfer += iprot->readFieldBegin(fname, ftype, fid);

    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }

    switch (fid) {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->rc);
          this->__isset.rc = true;
        } else {
          xfer += iprot->skip(ftype);
        }

        break;

      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->msg);
          this->__isset.msg = true;
        } else {
          xfer += iprot->skip(ftype);
        }

        break;

      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }

        break;

      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->query);
          this->__isset.query = true;
        } else {
          xfer += iprot->skip(ftype);
        }

        break;

      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->entities.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->entities.resize(_size2);
            uint32_t _i6;

            for (_i6 = 0; _i6 < _size2; ++_i6) {
              xfer += this->entities[_i6].read(iprot);
            }

            xfer += iprot->readListEnd();
          }
          this->__isset.entities = true;
        } else {
          xfer += iprot->skip(ftype);
        }

        break;

      default:
        xfer += iprot->skip(ftype);
        break;
    }

    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Data");

  if (this->__isset.rc) {
    xfer += oprot->writeFieldBegin("rc", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->rc);
    xfer += oprot->writeFieldEnd();
  }

  if (this->__isset.msg) {
    xfer += oprot->writeFieldBegin("msg", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->msg);
    xfer += oprot->writeFieldEnd();
  }

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->error);
    xfer += oprot->writeFieldEnd();
  }

  if (this->__isset.query) {
    xfer += oprot->writeFieldBegin("query", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->query);
    xfer += oprot->writeFieldEnd();
  }

  if (this->__isset.entities) {
    xfer += oprot->writeFieldBegin("entities", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->entities.size()));
      std::vector<Entity> ::const_iterator _iter7;

      for (_iter7 = this->entities.begin(); _iter7 != this->entities.end(); ++_iter7) {
        xfer += (*_iter7).write(oprot);
      }

      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Data &a, Data &b) {
  using ::std::swap;
  swap(a.rc, b.rc);
  swap(a.msg, b.msg);
  swap(a.error, b.error);
  swap(a.query, b.query);
  swap(a.entities, b.entities);
  swap(a.__isset, b.__isset);
}

Data::Data(const Data& other8) {
  rc = other8.rc;
  msg = other8.msg;
  error = other8.error;
  query = other8.query;
  entities = other8.entities;
  __isset = other8.__isset;
}
Data& Data::operator=(const Data& other9) {
  rc = other9.rc;
  msg = other9.msg;
  error = other9.error;
  query = other9.query;
  entities = other9.entities;
  __isset = other9.__isset;
  return *this;
}
void Data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Data(";
  out << "rc=";
  (__isset.rc ? (out << to_string(rc)) : (out << "<null>"));
  out << ", " << "msg=";
  (__isset.msg ? (out << to_string(msg)) : (out << "<null>"));
  out << ", " << "error=";
  (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "query=";
  (__isset.query ? (out << to_string(query)) : (out << "<null>"));
  out << ", " << "entities=";
  (__isset.entities ? (out << to_string(entities)) : (out << "<null>"));
  out << ")";
}

}
}
} // namespace
