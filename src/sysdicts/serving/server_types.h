/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef server_TYPES_H
#define server_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>


namespace chatopera { namespace bot { namespace sysdicts {

typedef std::string Timestamp;

class Entity;

class Data;

typedef struct _Entity__isset {
  _Entity__isset() : slotname(false), dictname(false), val(false), score(false) {}
  bool slotname :1;
  bool dictname :1;
  bool val :1;
  bool score :1;
} _Entity__isset;

class Entity : public virtual ::apache::thrift::TBase {
 public:

  Entity(const Entity&);
  Entity& operator=(const Entity&);
  Entity() : slotname(), dictname(), val(), score(0) {
  }

  virtual ~Entity() throw();
  std::string slotname;
  std::string dictname;
  std::string val;
  double score;

  _Entity__isset __isset;

  void __set_slotname(const std::string& val);

  void __set_dictname(const std::string& val);

  void __set_val(const std::string& val);

  void __set_score(const double val);

  bool operator == (const Entity & rhs) const
  {
    if (__isset.slotname != rhs.__isset.slotname)
      return false;
    else if (__isset.slotname && !(slotname == rhs.slotname))
      return false;
    if (__isset.dictname != rhs.__isset.dictname)
      return false;
    else if (__isset.dictname && !(dictname == rhs.dictname))
      return false;
    if (__isset.val != rhs.__isset.val)
      return false;
    else if (__isset.val && !(val == rhs.val))
      return false;
    if (__isset.score != rhs.__isset.score)
      return false;
    else if (__isset.score && !(score == rhs.score))
      return false;
    return true;
  }
  bool operator != (const Entity &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Entity & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Entity &a, Entity &b);

std::ostream& operator<<(std::ostream& out, const Entity& obj);

typedef struct _Data__isset {
  _Data__isset() : rc(false), msg(false), error(false), query(false), entities(false) {}
  bool rc :1;
  bool msg :1;
  bool error :1;
  bool query :1;
  bool entities :1;
} _Data__isset;

class Data : public virtual ::apache::thrift::TBase {
 public:

  Data(const Data&);
  Data& operator=(const Data&);
  Data() : rc(0), msg(), error(), query() {
  }

  virtual ~Data() throw();
  int32_t rc;
  std::string msg;
  std::string error;
  std::string query;
  std::vector<Entity>  entities;

  _Data__isset __isset;

  void __set_rc(const int32_t val);

  void __set_msg(const std::string& val);

  void __set_error(const std::string& val);

  void __set_query(const std::string& val);

  void __set_entities(const std::vector<Entity> & val);

  bool operator == (const Data & rhs) const
  {
    if (__isset.rc != rhs.__isset.rc)
      return false;
    else if (__isset.rc && !(rc == rhs.rc))
      return false;
    if (__isset.msg != rhs.__isset.msg)
      return false;
    else if (__isset.msg && !(msg == rhs.msg))
      return false;
    if (__isset.error != rhs.__isset.error)
      return false;
    else if (__isset.error && !(error == rhs.error))
      return false;
    if (__isset.query != rhs.__isset.query)
      return false;
    else if (__isset.query && !(query == rhs.query))
      return false;
    if (__isset.entities != rhs.__isset.entities)
      return false;
    else if (__isset.entities && !(entities == rhs.entities))
      return false;
    return true;
  }
  bool operator != (const Data &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Data & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Data &a, Data &b);

std::ostream& operator<<(std::ostream& out, const Data& obj);

}}} // namespace

#endif
